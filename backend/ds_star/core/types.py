"""Core data types for DS-STAR."""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any


class StepStatus(Enum):
    """Status of a plan step."""

    PENDING = "pending"
    EXECUTING = "executing"
    COMPLETED = "completed"
    FAILED = "failed"
    BACKTRACKED = "backtracked"


class VerificationResult(Enum):
    """Result from the Verifier agent."""

    SUFFICIENT = "sufficient"
    INSUFFICIENT = "insufficient"


class RouterDecision(Enum):
    """Decision from the Router agent."""

    ADD_STEP = "add_step"
    BACKTRACK = "backtrack"


@dataclass
class FileDescription:
    """Description generated by Analyzer for a data file."""

    path: str
    file_type: str  # csv, json, xlsx, md, txt, etc.
    description: str
    schema: dict[str, Any] | None = None  # Column info for tabular data
    sample_data: str | None = None
    row_count: int | None = None
    size_bytes: int | None = None


@dataclass
class Step:
    """A single high-level plan step."""

    index: int
    description: str
    status: StepStatus = StepStatus.PENDING
    created_at: datetime = field(default_factory=datetime.now)

    def __str__(self) -> str:
        return f"Step {self.index}: {self.description}"


@dataclass
class CodeBlock:
    """Generated Python code for implementing steps."""

    code: str
    step_indices: list[int] = field(default_factory=list)  # Steps this code implements


@dataclass
class ExecutionResult:
    """Result from executing a code block."""

    success: bool
    stdout: str = ""
    stderr: str = ""
    error_traceback: str | None = None
    return_value: Any = None
    execution_time_ms: float = 0.0


@dataclass
class RouterOutput:
    """Output from Router agent."""

    decision: RouterDecision
    backtrack_to_step: int | None = None  # Only if decision is BACKTRACK
    reasoning: str = ""


@dataclass
class DSStarState:
    """Complete state of a DS-STAR session."""

    query: str
    data_files: list[str]
    file_descriptions: list[FileDescription] = field(default_factory=list)
    steps: list[Step] = field(default_factory=list)
    current_code: CodeBlock | None = None
    execution_results: list[ExecutionResult] = field(default_factory=list)
    iteration: int = 0
    is_complete: bool = False
    final_answer: str | None = None

    @property
    def last_execution_result(self) -> ExecutionResult | None:
        """Get the most recent execution result."""
        return self.execution_results[-1] if self.execution_results else None

    @property
    def current_plan(self) -> list[Step]:
        """Get all non-backtracked steps."""
        return [s for s in self.steps if s.status != StepStatus.BACKTRACKED]

    def get_file_descriptions_text(self) -> str:
        """Format file descriptions for prompts."""
        if not self.file_descriptions:
            return "No file descriptions available."

        lines = []
        for desc in self.file_descriptions:
            lines.append(f"File: {desc.path}")
            lines.append(f"  Type: {desc.file_type}")
            lines.append(f"  Description: {desc.description}")
            if desc.schema:
                lines.append(f"  Schema: {desc.schema}")
            if desc.row_count is not None:
                lines.append(f"  Rows: {desc.row_count}")
            lines.append("")
        return "\n".join(lines)

    def get_steps_text(self) -> str:
        """Format current plan steps for prompts."""
        if not self.current_plan:
            return "No steps yet."

        lines = []
        for step in self.current_plan:
            status_marker = "[DONE]" if step.status == StepStatus.COMPLETED else "[TODO]"
            lines.append(f"{status_marker} Step {step.index}: {step.description}")
        return "\n".join(lines)

    def get_execution_summary(self) -> str:
        """Format execution results for prompts."""
        if not self.execution_results:
            return "No execution results yet."

        result = self.execution_results[-1]
        lines = [
            f"Success: {result.success}",
            f"Execution time: {result.execution_time_ms:.2f}ms",
        ]
        if result.stdout:
            lines.append(f"Output:\n{result.stdout[:8000]}")
        if result.stderr:
            lines.append(f"Stderr:\n{result.stderr[:2000]}")
        if result.error_traceback:
            lines.append(f"Error:\n{result.error_traceback[:2000]}")

        return "\n".join(lines)
